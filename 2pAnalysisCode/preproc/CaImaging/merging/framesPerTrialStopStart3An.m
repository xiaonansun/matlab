function [framesPerTrial, trialNumbers, frame1RelToStartOff, badAlignments] = ...
  framesPerTrialStopStart3An(binFilename, framecountFilename, headerBug)
% [framesPerTrial, trialNumbers, frame1RelToStartOff, badAlignments] = ...
%   framesPerTrialStopStart3An(binFilename, framecountFilename [, headerBug])
%
% This goal of this function is to take two inputs (the analog signal
% acquired alongside the calcium imaging, and the framecounts.txt file
% generated by the script running on the scope) and parse them out to
% identify the frames corresponding to each trial.
%
% Expects a .bin file containing 4 analog channels:
%  AI0: trial codes (encoded as a modified "interleaved 2 of 5" barcode)
%  AI1: slow galvo signal
%  AI2: "trial start" signal (36 ms TTL at start of trial)
%  AI3: dummy channel, not used (but must be present to avoid bug in MScan)
%
% This process is a little complicated, because neither BControl nor MScan
% is totally reliable.
%
% On the BControl side, sometimes the start TTL and trial code seem to be
% missing, but there is an interruption in the slow galvo signal that can
% be used to identify trials that need to be broken up.
%
% On the MScan side, the analog signal and the scanning have no intrinsic
% time alignment signals because of bad design in MScan. It would seem that
% the slow galvo signal should be enough to reconstruct the timing.
% However, the slow galvo signal by itself is not adequate because MScan
% usually drops any final partial frame, but not always (sometimes it
% finishes that partial frame out, and saves it like any other frame). So
% instead we use a combination of the frame counts recorded in
% framecounts.txt and the slow galvo signal; framecounts.txt appears to be
% totally reliable (except when BControl messes up; see above).
%
% Trial numbers are aligned using the "bar codes" that get sent over AI0.
% Rarely, these get lost or are mangled. In those cases, they are usually
% repairable, or can be inferred. If this endangers time alignment, those
% trials are marked as having problematic alignment in badAlignments.
%
% INPUTS
%   binFilename        -- path to the .bin file containing the analog
%                         signals
%   framecountFilename -- path to the framecounts.txt file
%   headerBug          -- optional. Should be true if recording was made
%                         using MView 3.?.?.?, which writes slightly broken
%                         file headers. Default false.
%
% OUTPUTS
%   framesPerTrial     -- vector of length nTrials. Contains the number of
%                         frames per trial
%   trialNumbers       -- vector of the trial numbers. If values are
%                         negative, this means that the code was damaged
%                         and could not be inferred even with the help of
%                         surrounding trials
%   frame1RelToStartOff -- when the first frame of this trial started,
%                          relative to the offset of the initial TTL on the
%                          startTrial line
%   badAlignments      -- trials that could not be aligned, due to missing
%                         signals or mismatches between signals


%% Parameters

voltageThresh = 1.5;


%% Optional arguments

if ~exist('headerBug', 'var')
  headerBug = 0;
end


%% Read binary file

volt = readMOMAnalog(binFilename, headerBug);

trialCodes = volt(1, :);
slowGalvo = volt(2, :);
trialStart = volt(3, :);


%% Find trial start and end samples

trialStart(trialStart < voltageThresh) = 0;
trialStart(trialStart >= voltageThresh) = 1;
startOnSamples = find(diff(trialStart) == 1) + 1;
if trialStart(1) == 1
  startOnSamples = [1 startOnSamples];
end

startOffSamples = find(diff(trialStart) == -1);

nTrials = length(startOnSamples);


%% Get trial numbers

[trialNumbers, codeTimes] = segmentVoltageAndReadBarcodes(trialCodes);


%% Cross-check start TTLs and trial numbers
% Whenever there's a lost start or a lost trial code, repair it and mark it
% as bad later. We can identify them because missing values cause a
% misalignment.

repaired = [];
fixedCodes = [];
while 1
  minLen = min(length(trialNumbers), length(startOffSamples));
  diffs = (startOffSamples(1:minLen) + 1) - codeTimes(1:minLen);
  firstBad = find(abs(diffs) > 10, 1);
  
  if isempty(firstBad)
    break;
  end
  
  % Figure out whether this error is a missing trial start, or a missing
  % trial code
  if diffs(firstBad) > 10
    % Missing trial start
    % Presumably due to a delay in starting the scope. We'll repair it for
    % now so everything lines up, then mark the trial as not aligned at the
    % end.

    % Insert placeholder value to make everything else go smoothly, then
    % mark this trial as bad later
    startOnSamples = insertIntoArray(startOnSamples, firstBad, codeTimes(firstBad));
    startOffSamples = insertIntoArray(startOffSamples, firstBad, codeTimes(firstBad));
    nTrials = length(startOnSamples);
    repaired(end+1) = firstBad;

  elseif diffs(firstBad) < 10
    % Missing trial code
    % Presumably the mouse broke fixation before the trial code was sent
    
    trialNumbers = insertIntoArray(trialNumbers, firstBad, NaN);
    codeTimes = insertIntoArray(codeTimes, firstBad, startOffSamples(firstBad) + 1);
    fixedCodes(end+1) = firstBad;
    
  else
    % Something wrong, probably a NaN somehow
    error('framesPerTrialStopStart3An:missingUnknown', 'Can''t figure out whether a trial start or a trial code is missing');
  end
end



% We've now fixed any misalignments up to the common lengths of the arrays,
% but must check for trailing problems.
if length(trialNumbers) > nTrials
  nExcess = length(trialNumbers) - nTrials;
  badIndices = length(trialNumbers) - nExcess + 1 : length(trialNumbers);
  startOnSamples = [startOnSamples codeTimes(badIndices)];
  startOffSamples = [startOffSamples codeTimes(badIndices)];
  nTrials = length(startOnSamples);
  repaired = [repaired badIndices];
end

if length(trialNumbers) < nTrials
  nExcess = nTrials - length(trialNumbers);
  badIndices = nTrials - nExcess + 1 : nTrials;
  trialNumbers = [trialNumbers NaN(1, nExcess)];
  codeTimes = [codeTimes startOffSamples(badIndices)+1];
  fixedCodes = [fixedCodes badIndices];
end

if ~isempty(repaired)
  fprintf('%d trials were missing trial start TTLs and were repaired, but cannot be aligned\n', length(repaired));
end


% Now try to repair any fixed trial codes
if ~isempty(fixedCodes)
  nFixed = 0;
  
  for code = fixedCodes
    % If this is the first code, can only repair if the next code is 2
    if code == 1
      if nTrials > 1 && trialNumbers(code + 1) == 2
        trialNumbers(1) = 1;
        nFixed = nFixed + 1;
      end
      continue;
    end
    
    % Can only hope to repair a code if the previous code is non-NaN
    % (unless this is the first trial, handled above). Otherwise, we're in
    % a block of undeterminable trials codes.
    if isnan(trialNumbers(code - 1))
      continue;
    end
    
    % Run forward to find the next non-NaN code
    next = code + 1;
    while next <= nTrials
      if ~isnan(trialNumbers(next))
        break;
      end
      next = next + 1;
    end
    
    if next <= nTrials
      % Can only repair if we haven't lost any whole trials in this run of
      % NaNs
      if trialNumbers(next) - trialNumbers(code - 1) == next - (code - 1)
        trialNumbers(code) = trialNumbers(code - 1) + 1;
        nFixed = nFixed + 1;
      end
    end
  end

  fprintf('%d trials were missing trial codes. Of these, %d could be repaired.\n', length(fixedCodes), nFixed);
end


%% Cross-check start-TTL-off times and code-on times. Repair if needed.

diffs = (startOffSamples + 1) - codeTimes;
badAlignments = (isnan(diffs) | abs(diffs) > 1);
if any(badAlignments)
  warning('%d start-off samples did not line up with code onsets by more than one sample', sum(badAlignments));
end
badAlignment(repaired) = true;


% %% Debugging
% 
% figure;
% hold on;
% 
% plot(slowGalvo);
% plot(startOnSamples, slowGalvo(startOnSamples), 'r.');
% plot(startOnSamples-1, slowGalvo(startOnSamples-1), 'g.');


%% Use the slow galvo signal to identify frames

% The -5 below should only need to be -1, but need slop in case a code is
% slightly late; this happens on rare occasions
trialEndSamples = [startOnSamples(2:end)-5 length(slowGalvo)];
framesPerTrial = cell(1, nTrials);
frame1RelToStartOff = NaN(1, nTrials);
for tr = 1:nTrials
  framesPerTrial{tr} = parseSlowGalvo(slowGalvo(startOnSamples(tr):trialEndSamples(tr)));
  frame1RelToStartOff(tr) = -(startOffSamples(tr) - startOnSamples(tr) + 1);
end


%% If we found any "trial" was actually more than one trial, deal with it
% Sometimes, we see a brief pause in the galvo trace, then it resumes
% without seeing a code or trial start. This might be due to when BControl
% is paused and unpaused. In any case, we need to fix these, because
% otherwise we'll match up trial codes with trials wrong.

multChunks = find(cellfun(@length, framesPerTrial) > 1);
if ~isempty(multChunks)
  frame1RelToStartOff = insertIntoArray(frame1RelToStartOff, multChunks, NaN);
  trialNumbers = insertIntoArray(trialNumbers, multChunks, NaN);
%   for m = fliplr(multChunks)
%     if m == 1
%       framesPerTrial = [num2cell(framesPerTrial{m}) framesPerTrial(m+1:end)];
%     elseif m == length(framesPerTrial)
%       framesPerTrial = [framesPerTrial(1:m-1) num2cell(framesPerTrial{m})];
%     else
%       framesPerTrial = [framesPerTrial(1:m-1) num2cell(framesPerTrial{m}) framesPerTrial(m+1:end)];
%     end
%   end
  
  fprintf('%d trial(s) found tacked on to ends of known trials and repaired, but missing alignment info\n', ...
    sum(isnan(frame1RelToStartOff)));
end

framesPerTrial = [framesPerTrial{:}];


%% If given, parse the frame count file

if exist('framecountFilename', 'var') && ~isempty(framecountFilename)
  framecountFrames = NaN(1, nTrials);
  
  % Open file
  try
    fid = fopen(framecountFilename, 'r');
  catch
    warning('Could not open frame count file %s', framecountFilename);
    return;
  end
  
  % Read each line, keep only the initial number
  line = 0;
  while 1
    line = line + 1;
    oneLine = fgetl(fid);
    if ~ischar(oneLine) || isempty(oneLine)
      break;
    end
    
    tokens = simpleTokenize(oneLine, ' ');
    numStr = tokens{1};
    framecountFrames(line) = str2double(numStr);
  end
  
  if length(framecountFrames) ~= length(framesPerTrial)
    error('framesPerTrialStopStart3An:trialCountMismatch', ...
      ['Found %d trials in framecounts.txt, but %d trials in the galvo trace. ' ...
      'Cannot determine which trial has which frame count!'], ...
      length(framecountFrames), length(framesPerTrial));
  end
  
  if any(abs(framecountFrames - framesPerTrial) > 1)
    error('framesPerTrialStopStart3An:galvoMismatch', ...
      'framecounts.txt and galvo trace disagree by >1 frame for %d trials', ...
      sum(abs(framecountFrames - framesPerTrial) > 1));
  end
  
%   % Compare with frame counts from the analog channels
%   figure;
%   hold on;
%   plot(framecountFrames, 'b');
%   plot(framesPerTrial, 'r');
%   
%   figure;
%   plot(framecountFrames - framesPerTrial, 'k');
  
  % Summarize
  fprintf('For reference (not a problem): galvo trace missing %d frames.\n', sum(framecountFrames) - sum(framesPerTrial));
  
else
  warning('No framecounts.txt supplied. Alignment is very likely to drift over trials!');
end



% %% Plot some galvo traces with inferred frames, to see what's up
% 
% samplesPerFrame = 1000 / 30.9;  % Is this value exact?
% 
% trsWrong = find(framecountFrames - framesPerTrial ~= 0, 3);
% 
% trsRight = find(framecountFrames - framesPerTrial == 0, 3);
% 
% % This is all uncorrected for chunk splits!
% for tr = trsWrong
%   figure;
%   hold on;
%   plot(slowGalvo(startOnSamples(tr):trialEndSamples(tr)));
%   for t = 1:framesPerTrial(tr)
%     plot((1 + t * samplesPerFrame) * [1 1], [-3 3], 'r-');
%   end
%   title(sprintf('%d inferred (wrong)', framesPerTrial(tr)));
% end
% 
% for tr = trsRight
%   figure;
%   hold on;
%   plot(slowGalvo(startOnSamples(tr):trialEndSamples(tr)));
%   for t = 1:framesPerTrial(tr)
%     plot((1 + t * samplesPerFrame) * [1 1], [-3 3], 'r-');
%   end
%   title(sprintf('%d inferred (right)', framesPerTrial(tr)));
% end

% %% List the frames where there was disagreement between the galvo signal and framecounts.txt
% % Empirically, there's nothing obviously wrong with these frames.
% 
% cumFrames = cumsum(framecountFrames);
% disagreementTrials = find((framecountFrames - framesPerTrial) ~= 0);
% fprintf('Disagreements between galvo signal and framecounts:\n');
% for d = disagreementTrials
%   fprintf('%d\n', cumFrames(d));
% end



%% Go with framecounts.txt

% framecounts.txt gives the more reliable answer
if exist('framecountFilename', 'var') && ~isempty(framecountFilename)
  framesPerTrial = framecountFrames;
end


%% Mark the repaired trials as not aligned

frame1RelToStartOff(repaired) = NaN;




function nFrames = parseSlowGalvo(galvo)

% First get rid of any initial non-scanning
if galvo(1) == galvo(2) && galvo(1) == galvo(3)
  firstRealValue = find(galvo ~= galvo(1), 1);
  galvo = galvo(firstRealValue:end);
end

% First, look for whether there are breaks in the middle of scanning,
% indicating trials that weren't separated correctly.

chunks = breakScanningChunks(galvo);

samplesPerFrame = 1000 / 30.9;  % Is this value exact?

nFrames = cellfun(@(c) floor(length(c) / samplesPerFrame), chunks);




function chunks = breakScanningChunks(galvo)
% This function looks to see whether scanning stopped in the middle of what
% should be a single trial. If so, break it up.

% This should happen rarely, so it's ok to use a slightly inefficient
% recursive algorithm for convenience.

% To find scan stops, we'll look for 3 consecutive identical values not at
% the end.
runs = (galvo(1:end-2) == galvo(2:end-1) & galvo(1:end-2) == galvo(3:end));
firstRun = find(runs, 1);
lastNonRun = find(runs == 0, 1, 'last');
if isempty(firstRun)
  chunks = {galvo};
elseif isempty(lastNonRun) || firstRun == lastNonRun + 1
  chunks = {galvo(1:firstRun - 1)};
else
  endOfFirstRun = firstRun + find(runs(firstRun+1:end) == 0, 1);
  chunks = [{galvo(1:firstRun - 1)} breakScanningChunks(galvo(endOfFirstRun:end))];
end
